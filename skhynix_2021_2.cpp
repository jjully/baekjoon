//1번 문제

//GBBB
//GGBB
//GGGB
//GGGG
//BGGG
//BBGG
//BBBG
//BBBB      이런 식으로 출력. n을 입력 받으면 가로 길이가 n, 세로 길이는 (2n-1)
//          그냥 쌩으로 위에서부터 가운데 GGGG까지 string add 후, BGGG부터 BBBB까지 string add
//          이후 전체 출력


//2번 문제
//n명의 weight가 weight vector로 주어지고, 양쪽에 weight 합이 같으면서 최대한 많은 인원이 시합에 참가할 수 있는 방법
//최대 x명이 결정된 이후에는 그 중 weight 합이 가장 큰 경우를 선택해서 [x, weight] 로 출력
//시간이 부족해서 못풀었음
//teamA 와 teamB 를 나눠서 생각하지 않을 경우 1명에도 A라는 사람이 들어가고 x-1명에도 A라는 사람이 들어간 경우 weight가 같다고 판단할 수 있으므로 안 됨
//반드시 teamA와 teamB를 나눠야 함
//DFS를 이용해서 1<=x<=(n-1)에 대해서 사람 수가 채워질 경우 total weight를 totalweight[x]에 push_back하는 방식으로 저장
//이후 totalweight[x]와 totalweight[n-x]

//생각해봅시다,,

//3번 문제
//A, B 두 사람이 이동
//다른 지점에서 시작
//모든 지점을 최단 거리로 방문
//DFS
//각 상황마다 모든 방문하지 않은 destination에 대해서 A가 이동한 경우와 B가 이동한 경우를 다음 DFS로 넣음
//모든 상황에 대해서 최단 거리 측정 가능
//두 명 돌려야 된다 해서 처음에 뇌정지,,
//모든 지점이 연결되어 있다는 것이 힌트
//둘이 동시에 움직인다고 생각하지 않고, 한 곳씩 방문을 한다고 생각하며 누가 갈지를 결정해주는 걸로 DFS



//4번 문제
//네모 채우기
//[정사각형 길이, 정사각형 개수] 로 인풋이 들어옴
//작은 정사부터 map에 채워넣음
//{0, 0}부터 생각해서 채워넣기 시작하면서, 채워넣는 데에 성공할 경우 [x, y, recLength]로 output에 저장
//불가능할 경우 무시

//완전 심한 brute force로 구현했음
//솔직히 너무 비효율적이지 않나,,
//그래도 신경 쓴 부분은 메모리 접근할 때 index 순서 건너뛰기를 최소화 하여 붙어있는 메모리에 접근할 수 있도록 노력함
//ex. x, y 라면 [y][x], [y][x+1], [y][x+2], [y+1][x], .. 이런 식으로
//그리고 map에 그리는 데에 성공하면 그 길이만큼 x축 건너뛰도록 구현
